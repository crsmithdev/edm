<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDM Structure Annotator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0F1419;
            color: #E5E7EB;
            padding: 24px;
            font-size: 14px;
        }
        .container { max-width: 1600px; margin: 0 auto; }
        h1 {
            margin-bottom: 24px;
            color: #FFFFFF;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .controls {
            background: #1E2139;
            padding: 24px;
            border-radius: 14px;
            margin-bottom: 20px;
            border: 1px solid rgba(91, 124, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .control-row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            align-items: center;
        }
        select, input {
            padding: 10px 14px;
            border: 1px solid #2A2F4C;
            background: #151828;
            color: #E5E7EB;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
        }
        select:hover, input:hover {
            border-color: #5B7CFF;
        }
        select:focus, input:focus {
            outline: none;
            border-color: #5B7CFF;
            box-shadow: 0 0 0 3px rgba(91, 124, 255, 0.1);
        }
        select { flex: 1; max-width: 400px; }
        input[type="number"] { width: 100px; }
        button {
            background: #5B7CFF;
            color: #FFFFFF;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            border-radius: 8px;
            padding: 10px 18px;
            font-family: inherit;
        }
        button:hover {
            background: #4A6BEE;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(91, 124, 255, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            background: #2A2F4C;
            color: #6B7280;
            cursor: not-allowed;
            transform: none;
        }

        .waveform-container {
            background: #1E2139;
            padding: 24px;
            border-radius: 14px;
            margin-bottom: 20px;
            position: relative;
            border: 1px solid rgba(91, 124, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .waveform-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 16px;
            justify-content: flex-end;
        }
        #waveform {
            width: 100%;
            height: 300px;
            background: #151828;
            border: 1px solid #2A2F4C;
            border-radius: 10px;
            cursor: crosshair;
            position: relative;
            overflow: hidden;
        }
        #waveform.dragging { cursor: grabbing; }
        .beat-grid-line {
            position: absolute;
            width: 1px;
            height: 100%;
            top: 0;
            pointer-events: none;
        }
        .beat-grid-line.bar { background: #ff9800; opacity: 0.6; width: 2px; }
        .beat-grid-line.beat { background: #666; opacity: 0.4; }
        .beat-grid-line.downbeat { background: #f44336; opacity: 0.8; width: 3px; }
        .bar-number {
            position: absolute;
            top: 2px;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 10px;
            color: #ff9800;
            pointer-events: none;
        }
        .marker {
            position: absolute;
            width: 2px;
            height: 100%;
            top: 0;
            cursor: pointer;
        }
        .marker-label {
            position: absolute;
            top: -25px;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
        }
        .region-overlay {
            position: absolute;
            height: 100%;
            top: 0;
            pointer-events: none;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
            border-right: 2px solid rgba(255, 255, 255, 0.3);
            transition: opacity 0.2s;
        }
        .region-overlay.highlight {
            opacity: 0.45 !important;
            border-left: 3px solid rgba(91, 124, 255, 0.8);
            border-right: 3px solid rgba(91, 124, 255, 0.8);
        }

        .boundaries {
            margin-top: 20px;
        }
        .boundaries h2 {
            margin-bottom: 18px;
            font-size: 18px;
            font-weight: 700;
            color: #FFFFFF;
            letter-spacing: -0.01em;
        }
        .boundary-item {
            background: #151828;
            padding: 14px 16px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
            border: 1px solid #2A2F4C;
        }
        .boundary-item:hover {
            background: #1A1F38;
            border-color: #5B7CFF;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .boundary-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        .boundary-time {
            font-weight: 600;
            color: #5B7CFF;
            min-width: 120px;
            font-size: 14px;
        }
        .boundary-bar {
            font-weight: 500;
            color: #9CA3AF;
            min-width: 100px;
            font-size: 12px;
        }
        .label-dropdown {
            padding: 6px 12px;
            border: 1px solid #2A2F4C;
            background: #0F1419;
            color: #E5E7EB;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }
        .label-dropdown:hover {
            background: #1A1F38;
            border-color: #5B7CFF;
        }

        .btn-delete {
            background: #FF6B6B;
            padding: 6px 14px;
            font-size: 12px;
            border-radius: 6px;
        }
        .btn-delete:hover {
            background: #EE5A5A;
        }

        .status {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: #00E6B8;
            color: #0F1419;
            padding: 14px 20px;
            border-radius: 10px;
            display: none;
            font-weight: 600;
            animation: slideIn 0.3s;
            box-shadow: 0 6px 20px rgba(0, 230, 184, 0.3);
        }
        @keyframes slideIn {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }


        .navigation-row label {
            font-weight: 700;
            min-width: 60px;
            color: #00E6B8;
            font-size: 14px;
            flex-shrink: 0;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .nav-btn {
            padding: 12px 16px;
            font-size: 13px;
            background: #151828;
            color: #E5E7EB;
            border: 1px solid #2A2F4C;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 44px;
            min-width: 70px;
        }
        .nav-btn:hover {
            background: #1A1F38;
            border-color: #5B7CFF;
        }
        .zoom-btn {
            padding: 8px 16px;
            font-size: 16px;
            font-weight: 700;
            background: #151828;
            border: 1px solid #2A2F4C;
        }
        .zoom-btn:hover {
            background: #1A1F38;
            border-color: #5B7CFF;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 3fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .controls-column {
            background: #1E2139;
            padding: 20px;
            border-radius: 14px;
            border: 1px solid rgba(91, 124, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .track-list-column {
            background: #1E2139;
            padding: 20px;
            border-radius: 14px;
            border: 1px solid rgba(91, 124, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            height: fit-content;
            max-height: 600px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .track-list-column h3 {
            margin-bottom: 12px;
            color: #FFFFFF;
            font-size: 16px;
            font-weight: 700;
        }

        .track-controls {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid #2A2F4C;
        }

        .track-controls .control-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .track-controls input {
            width: 100%;
        }

        .track-controls button {
            width: 100%;
        }

        .instructions {
            margin-top: 30px;
            font-size: 12px;
            line-height: 1.8;
            color: #6B7280;
        }

        .instructions strong {
            color: #9CA3AF;
            font-weight: 600;
        }

        .info-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 16px;
            background: #151828;
            border: 1px solid #2A2F4C;
            border-radius: 8px;
            height: 44px;
        }
        .info-label {
            font-size: 11px;
            font-weight: 600;
            color: #6B7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .info-value {
            font-size: 16px;
            font-weight: 700;
            color: #00E6B8;
            font-variant-numeric: tabular-nums;
        }

        .track-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            overflow-y: auto;
            padding-right: 8px;
        }

        .track-list::-webkit-scrollbar {
            width: 8px;
        }

        .track-list::-webkit-scrollbar-track {
            background: #151828;
            border-radius: 4px;
        }

        .track-list::-webkit-scrollbar-thumb {
            background: #2A2F4C;
            border-radius: 4px;
        }

        .track-list::-webkit-scrollbar-thumb:hover {
            background: #5B7CFF;
        }

        .track-item {
            padding: 10px 12px;
            background: #151828;
            border: 1px solid #2A2F4C;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .track-item:hover {
            background: #1A1F38;
            border-color: #5B7CFF;
        }

        .track-item.selected {
            background: #5B7CFF;
            color: #FFFFFF;
            border-color: #5B7CFF;
        }


        .transport-row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 20px;
            align-items: center;
            padding-bottom: 20px;
        }
        .navigation-row {
            display: flex;
            gap: 10px;
            align-items: stretch;
            justify-content: center;
            padding-bottom: 20px;
            margin-bottom: 20px;
            border-bottom: 1px solid #2A2F4C;
        }
        .editing-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }
        .control-group {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            align-items: stretch;
        }
        .control-group.info-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }
        .transport-btn {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            background: #2A2F4C;
            color: #E5E7EB;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 44px;
        }
        .transport-btn:hover {
            background: #3A3F5C;
            transform: translateY(-1px);
        }
        .transport-btn.play-btn {
            background: #00E6B8;
            color: #0F1419;
        }
        .transport-btn.play-btn:hover {
            background: #00D4A8;
            box-shadow: 0 4px 12px rgba(0, 230, 184, 0.3);
        }
        .transport-btn.play-btn.playing {
            background: #FF6B6B;
            color: #FFFFFF;
        }
        .transport-btn.play-btn.playing:hover {
            background: #EE5A5A;
        }
        .transport-btn#cueBtn {
            background: #FFB800;
            color: #0F1419;
        }
        .transport-btn#cueBtn:hover {
            background: #FFA500;
            box-shadow: 0 4px 12px rgba(255, 184, 0, 0.3);
        }
        .action-btn {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            background: #5B7CFF;
            color: #FFFFFF;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 44px;
        }
        .action-btn#jumpModeBtn {
            min-width: 80px;
        }
        .action-btn:hover {
            background: #4A6BEE;
            transform: translateY(-1px);
        }
        .action-btn.toggle-btn {
            background: #2A2F4C;
            color: #9CA3AF;
        }
        .action-btn.toggle-btn:hover {
            background: #3A3F5C;
            color: #E5E7EB;
        }
        .action-btn.toggle-btn.active {
            background: #5B7CFF;
            color: #FFFFFF;
        }
        .action-btn.toggle-btn.active:hover {
            background: #4A6BEE;
        }
        audio { display: none; }

        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            .track-list-column {
                max-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>EDM Structure Annotator</h1>

        <!-- Row 1: Waveform (Full Width) -->
        <audio id="audioPlayer" preload="auto"></audio>

        <div class="waveform-container">
            <div id="waveform"></div>
            <div class="waveform-controls">
                <button class="zoom-btn" onclick="zoom(-1)">âˆ’</button>
                <button class="zoom-btn" onclick="zoom(1)">+</button>
                <button class="zoom-btn" onclick="zoomToFit()">Reset</button>
            </div>
        </div>

        <!-- Row 2: Two Columns -->
        <div class="main-layout">
            <!-- Left Column: Controls -->
            <div class="controls-column">
                <div class="transport-row">
                    <div class="control-group">
                        <button class="transport-btn play-btn" id="playBtn" onclick="togglePlayback()">â–¶ Play</button>
                        <button class="transport-btn" id="cueBtn" onclick="returnToCue()">â†º Cue</button>
                        <button class="transport-btn" onclick="previousTrack()">â—€ Previous</button>
                        <button class="transport-btn" onclick="nextTrack()">Next â–¶</button>
                    </div>
                    <div class="control-group info-group">
                        <div class="info-display">
                            <span class="info-label">BPM</span>
                            <span class="info-value" id="bpmValue">--</span>
                        </div>
                        <div class="info-display">
                            <span class="info-label">Bar</span>
                            <span class="info-value" id="currentBar">1</span>
                        </div>
                        <div class="info-display">
                            <span class="info-label">Time</span>
                            <span class="info-value" id="currentTime">0:00.00</span>
                        </div>
                    </div>
                </div>

                <div class="editing-row">
                    <button class="action-btn" id="addBoundaryBtn" onclick="addBoundaryAtPlayhead()">+ Boundary</button>
                    <button class="action-btn" onclick="setDownbeatAtPlayhead()">Downbeat</button>
                    <button class="action-btn toggle-btn active" id="quantizeBtn" onclick="toggleQuantize()">Quantize</button>
                </div>

                <div class="navigation-row">
                    <button class="nav-btn" onclick="jump(-16)">â—€ 16</button>
                    <button class="nav-btn" onclick="jump(-8)">â—€ 8</button>
                    <button class="nav-btn" onclick="jump(-4)">â—€ 4</button>
                    <button class="nav-btn" onclick="jump(-2)">â—€ 2</button>
                    <button class="nav-btn" onclick="jump(-1)">â—€ 1</button>
                    <button class="action-btn toggle-btn active" id="jumpModeBtn" onclick="toggleJumpMode()">Beats</button>
                    <button class="nav-btn" onclick="jump(1)">1 â–¶</button>
                    <button class="nav-btn" onclick="jump(2)">2 â–¶</button>
                    <button class="nav-btn" onclick="jump(4)">4 â–¶</button>
                    <button class="nav-btn" onclick="jump(8)">8 â–¶</button>
                    <button class="nav-btn" onclick="jump(16)">16 â–¶</button>
                </div>

                <div class="boundaries">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h2>Regions (<span id="regionCount">0</span>)</h2>
                        <button onclick="saveAnnotation()">ðŸ’¾ Save Annotation</button>
                    </div>
                    <div id="regionList"></div>
                </div>

            </div>

            <!-- Right Column: Track List -->
            <div class="track-list-column">
                <h3>Tracks</h3>
                <div id="trackList" class="track-list">
                    <div style="color: #6B7280; padding: 20px; text-align: center;">Loading tracks...</div>
                </div>
                <button id="loadBtn" class="action-btn" onclick="loadTrack()" style="width: 100%; margin-top: 12px;">Load Track</button>
            </div>
        </div>

        <div class="instructions">
            <strong>Workflow:</strong>
            Shift+Click waveform to add boundaries â†’ Label regions using dropdowns in list below<br>
            <strong>Navigate:</strong> Left/Right Â±4 bars | Ctrl+Left/Right Â±1 bar | Shift+Left/Right Â±8 bars | Up/Down previous/next track<br>
            <strong>Playback:</strong> Click waveform to set cue point | Spacebar play/pause | C/R return to cue | Drag to pan | Scroll to zoom<br>
            <strong>Editing:</strong> B add boundary | D set downbeat | Q toggle quantize
        </div>
    </div>

    <div id="status" class="status"></div>

    <script>
        let currentTrack = null;
        let boundaries = [];  // Array of time points (numbers)
        let regions = [];  // Array of {start, end, label}
        let waveformBass = [];
        let waveformMids = [];
        let waveformHighs = [];
        let waveformTimes = [];
        let duration = 0;
        let currentTime = 0;
        let currentBar = 1;
        let trackBPM = 128;  // Current track BPM
        let trackDownbeat = 0;  // Current track downbeat

        // Zoom and viewport state
        let zoomLevel = 1.0;  // 1.0 = full track visible
        let viewportStart = 0;  // Start time of viewport in seconds
        let viewportEnd = 0;  // End time of viewport in seconds
        let isDragging = false;
        let dragStartX = 0;
        let dragStartViewport = 0;

        // Audio playback
        let audioPlayer = null;
        let isPlaying = false;
        let animationFrame = null;

        // Quantize setting
        let quantizeEnabled = true;
        let jumpMode = 'beats'; // 'beats' or 'bars'

        // Cue point for DJ-style playback
        let cuePoint = 0;

        let selectedTrack = null;

        // Load track list on page load
        fetch('/api/tracks')
            .then(r => r.json())
            .then(tracks => {
                const trackList = document.getElementById('trackList');
                trackList.innerHTML = '';
                tracks.forEach(track => {
                    const item = document.createElement('div');
                    item.className = 'track-item';
                    const indicator = track.has_reference ? 'âœ“ ' : '';
                    item.textContent = indicator + track.filename;
                    item.title = track.filename;
                    item.dataset.filename = track.filename;
                    item.onclick = () => selectTrack(track.filename, item);
                    item.ondblclick = () => {
                        selectTrack(track.filename, item);
                        loadTrack();
                    };
                    trackList.appendChild(item);
                });
            });

        function selectTrack(filename, element) {
            selectedTrack = filename;
            // Update UI - highlight selected track
            document.querySelectorAll('.track-item').forEach(item => {
                item.classList.remove('selected');
            });
            element.classList.add('selected');
        }

        // Initialize audio player
        audioPlayer = document.getElementById('audioPlayer');

        // Sync playhead with audio playback
        function updatePlayhead() {
            if (audioPlayer && !audioPlayer.paused) {
                updateCurrentPosition(audioPlayer.currentTime, false);
                animationFrame = requestAnimationFrame(updatePlayhead);
            }
        }

        audioPlayer.addEventListener('play', () => {
            isPlaying = true;
            document.getElementById('playBtn').textContent = 'â¸ Pause';
            document.getElementById('playBtn').classList.add('playing');
            updatePlayhead();
        });

        audioPlayer.addEventListener('pause', () => {
            isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ Play';
            document.getElementById('playBtn').classList.remove('playing');
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            // Return to cue point when paused
            if (audioPlayer && audioPlayer.src) {
                audioPlayer.currentTime = cuePoint;
                updateCurrentPosition(cuePoint, false);
            }
        });

        audioPlayer.addEventListener('ended', () => {
            isPlaying = false;
            document.getElementById('playBtn').textContent = 'â–¶ Play';
            document.getElementById('playBtn').classList.remove('playing');
            // Return to cue point when ended
            audioPlayer.currentTime = cuePoint;
            updateCurrentPosition(cuePoint, false);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlayback();
                    break;
                case '+':
                case '=':
                    zoom(1);
                    break;
                case '-':
                case '_':
                    zoom(-1);
                    break;
                case '0':
                    zoomToFit();
                    break;
                case 'ArrowLeft':
                    if (e.shiftKey) {
                        jumpBars(-8);
                    } else if (e.ctrlKey || e.metaKey) {
                        jumpBars(-1);
                    } else {
                        jumpBars(-4);
                    }
                    break;
                case 'ArrowRight':
                    if (e.shiftKey) {
                        jumpBars(8);
                    } else if (e.ctrlKey || e.metaKey) {
                        jumpBars(1);
                    } else {
                        jumpBars(4);
                    }
                    break;
                case 'q':
                    toggleQuantize();
                    break;
                case 'd':
                    setDownbeatAtPlayhead();
                    break;
                case 'b':
                    addBoundaryAtPlayhead();
                    break;
                case 'c':
                case 'r':
                    returnToCue();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    previousTrack();
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    nextTrack();
                    break;
            }
        });

        function onBPMChange() {
            const bpmValue = document.getElementById('bpmInput').value;
            if (bpmValue) {
                document.getElementById('bpmValue').textContent = parseFloat(bpmValue).toFixed(1);
            }
            if (currentTrack) {
                drawWaveform();
            }
        }

        function onDownbeatChange() {
            if (currentTrack) {
                drawWaveform();
            }
        }
        function timeToBar(time) {
            const barDuration = 60.0 / trackBPM * 4.0;  // Duration of one bar in seconds
            const bar = Math.floor((time - trackDownbeat) / barDuration) + 1;
            return Math.max(1, bar);
        }

        function barToTime(bar) {
            const barDuration = 60.0 / trackBPM * 4.0;
            return trackDownbeat + (bar - 1) * barDuration;
        }

        function quantizeToBeat(time) {
            const beatDuration = 60.0 / trackBPM;  // One beat in seconds

            // Find nearest beat boundary
            const relativeTime = time - trackDownbeat;
            const beatIndex = Math.round(relativeTime / beatDuration);
            return trackDownbeat + beatIndex * beatDuration;
        }

        function toggleQuantize() {
            quantizeEnabled = !quantizeEnabled;
            const btn = document.getElementById('quantizeBtn');
            if (quantizeEnabled) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            showStatus(quantizeEnabled ? 'Quantize enabled - clicks snap to beat' : 'Quantize disabled');
        }

        function toggleJumpMode() {
            jumpMode = jumpMode === 'beats' ? 'bars' : 'beats';
            const btn = document.getElementById('jumpModeBtn');
            btn.textContent = jumpMode === 'beats' ? 'Beats' : 'Bars';
            showStatus(`Jump mode: ${jumpMode}`);
        }

        function jump(count) {
            if (jumpMode === 'beats') {
                jumpBeats(count);
            } else {
                jumpBars(count);
            }
        }

        function returnToCue() {
            if (!currentTrack) {
                showStatus('Load a track first!');
                return;
            }
            updateCurrentPosition(cuePoint);
            if (audioPlayer && !audioPlayer.paused) {
                audioPlayer.pause();
            }
            showStatus(`Returned to cue point: ${formatTime(cuePoint)}`);
        }

        function previousTrack() {
            const trackItems = Array.from(document.querySelectorAll('.track-item'));
            const currentIndex = trackItems.findIndex(item => item.classList.contains('selected'));

            if (currentIndex > 0) {
                const prevItem = trackItems[currentIndex - 1];
                selectTrack(prevItem.dataset.filename, prevItem);
                loadTrack();
            } else {
                showStatus('Already at first track');
            }
        }

        function nextTrack() {
            const trackItems = Array.from(document.querySelectorAll('.track-item'));
            const currentIndex = trackItems.findIndex(item => item.classList.contains('selected'));

            if (currentIndex >= 0 && currentIndex < trackItems.length - 1) {
                const nextItem = trackItems[currentIndex + 1];
                selectTrack(nextItem.dataset.filename, nextItem);
                loadTrack();
            } else {
                showStatus('Already at last track');
            }
        }

        function updateCurrentPosition(time, seekAudio = true) {
            currentTime = Math.max(0, Math.min(time, duration));
            currentBar = timeToBar(currentTime);
            document.getElementById('currentTime').textContent = formatTime(currentTime);
            document.getElementById('currentBar').textContent = currentBar;

            // Sync audio if seeking manually
            if (seekAudio && audioPlayer && audioPlayer.src) {
                audioPlayer.currentTime = currentTime;
            }

            drawPlayhead();
        }

        function togglePlayback() {
            if (!audioPlayer || !audioPlayer.src) {
                showStatus('Load a track first!');
                return;
            }

            if (isPlaying) {
                audioPlayer.pause();
            } else {
                // Play from cue point
                audioPlayer.currentTime = cuePoint;
                audioPlayer.play();
            }
        }

        function jumpBars(barCount) {
            if (!currentTrack) return;
            const newBar = currentBar + barCount;
            const newTime = barToTime(newBar);
            if (newTime >= 0 && newTime <= duration) {
                updateCurrentPosition(newTime);
            }
        }

        function jumpBeats(beatCount) {
            if (!currentTrack) return;
            const beatDuration = 60.0 / trackBPM;  // One beat in seconds
            const newTime = currentTime + (beatCount * beatDuration);
            if (newTime >= 0 && newTime <= duration) {
                updateCurrentPosition(newTime);
            }
        }

        function drawPlayhead() {
            // Remove old playhead
            document.querySelectorAll('.playhead').forEach(p => p.remove());

            // Only draw if in viewport
            if (currentTime >= viewportStart && currentTime <= viewportEnd) {
                const canvas = document.getElementById('waveform');
                const width = canvas.offsetWidth;
                const viewportDuration = viewportEnd - viewportStart;
                const x = ((currentTime - viewportStart) / viewportDuration) * width;

                const playhead = document.createElement('div');
                playhead.className = 'playhead';
                playhead.style.position = 'absolute';
                playhead.style.left = x + 'px';
                playhead.style.width = '3px';
                playhead.style.height = '100%';
                playhead.style.top = '0';
                playhead.style.background = '#00ff00';
                playhead.style.zIndex = '10';
                playhead.style.pointerEvents = 'none';

                canvas.appendChild(playhead);
            }
        }

        function zoom(direction, centerTime = null) {
            if (!currentTrack) return;

            // If no center provided, use playhead
            if (centerTime === null) {
                centerTime = currentTime;
            }

            // Zoom factor (2x per step)
            const factor = direction > 0 ? 0.5 : 2.0;
            const viewportDuration = viewportEnd - viewportStart;
            const newDuration = Math.min(duration, Math.max(1.0, viewportDuration * factor));

            // Calculate relative position of center in viewport
            const centerRatio = (centerTime - viewportStart) / viewportDuration;

            // Calculate new viewport maintaining center position
            let newStart = centerTime - newDuration * centerRatio;
            let newEnd = newStart + newDuration;

            // Clamp to bounds
            if (newStart < 0) {
                newStart = 0;
                newEnd = newDuration;
            }
            if (newEnd > duration) {
                newEnd = duration;
                newStart = duration - newDuration;
            }

            viewportStart = newStart;
            viewportEnd = newEnd;
            zoomLevel = duration / newDuration;

            drawWaveform();
        }

        function zoomToFit() {
            if (!currentTrack) return;
            zoomLevel = 1.0;
            viewportStart = 0;
            viewportEnd = duration;
            drawWaveform();
        }

        function setDownbeatAtPlayhead() {
            if (!currentTrack) return;
            trackDownbeat = currentTime;
            drawWaveform();
            showStatus('Downbeat set to ' + formatTime(currentTime));
        }

        let tapTimes = [];
        function tapTempo() {
            const now = Date.now();
            tapTimes.push(now);

            // Keep only last 4 taps
            if (tapTimes.length > 4) {
                tapTimes.shift();
            }

            // Calculate BPM from intervals
            if (tapTimes.length >= 2) {
                const intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i-1]);
                }
                const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                trackBPM = 60000 / avgInterval;  // Convert ms to BPM
                document.getElementById('bpmValue').textContent = trackBPM.toFixed(1);
                drawWaveform();
                showStatus(`BPM set to ${trackBPM.toFixed(1)} (${tapTimes.length} taps)`);
            } else {
                showStatus('Tap 1 - keep tapping...');
            }

            // Reset after 2 seconds of inactivity
            setTimeout(() => {
                if (Date.now() - tapTimes[tapTimes.length - 1] >= 2000) {
                    tapTimes = [];
                }
            }, 2000);
        }

        function loadTrack() {
            const filename = selectedTrack;
            if (!filename) {
                showStatus('Please select a track from the list');
                return;
            }

            const loadBtn = document.getElementById('loadBtn');
            loadBtn.disabled = true;
            loadBtn.textContent = 'Loading...';

            fetch(`/api/load/${filename}`)
                .then(r => r.json())
                .then(data => {
                    currentTrack = data;
                    waveformBass = data.waveform_bass;
                    waveformMids = data.waveform_mids;
                    waveformHighs = data.waveform_highs;
                    waveformTimes = data.waveform_times;
                    duration = data.duration;
                    boundaries = [];
                    regions = [];

                    // Stop playback if currently playing
                    if (audioPlayer && !audioPlayer.paused) {
                        audioPlayer.pause();
                    }
                    if (animationFrame) {
                        cancelAnimationFrame(animationFrame);
                        animationFrame = null;
                    }

                    // Reset playback state
                    isPlaying = false;
                    document.getElementById('playBtn').textContent = 'â–¶ Play';
                    document.getElementById('playBtn').classList.remove('playing');

                    // Load audio for playback
                    audioPlayer.src = `/api/audio/${filename}`;
                    audioPlayer.load();

                    // Set BPM and downbeat from loaded data
                    trackBPM = data.bpm;
                    trackDownbeat = data.downbeat;
                    document.getElementById('bpmValue').textContent = trackBPM.toFixed(1);

                    zoomLevel = 1.0;
                    viewportStart = 0;
                    viewportEnd = duration;
                    cuePoint = 0;

                    // Automatically add boundaries at bar 1 and end of track
                    const bar1Time = barToTime(1);
                    addBoundary(bar1Time);
                    addBoundary(duration);

                    drawWaveform();
                    updateRegionList();
                    updateCurrentPosition(0, false);

                    loadBtn.disabled = false;
                    loadBtn.textContent = 'Load Track';
                    showStatus(`Track loaded! ${waveformBass.length} samples, ~${((waveformTimes[1] - waveformTimes[0]) * 1000).toFixed(1)}ms resolution (3-band)`);
                })
                .catch(err => {
                    console.error('Load error:', err);
                    loadBtn.disabled = false;
                    loadBtn.textContent = 'Load Track';
                    showStatus('Failed to load track: ' + err.message);
                });
        }

        function drawWaveform() {
            const canvas = document.getElementById('waveform');
            canvas.innerHTML = ''; // Clear existing

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.style.display = 'block';

            // Find samples in visible time range
            const viewportDuration = viewportEnd - viewportStart;
            let visibleIndices = [];
            let visibleBass = [];
            let visibleMids = [];
            let visibleHighs = [];

            for (let i = 0; i < waveformTimes.length; i++) {
                if (waveformTimes[i] >= viewportStart && waveformTimes[i] <= viewportEnd) {
                    visibleIndices.push(i);
                    visibleBass.push(waveformBass[i]);
                    visibleMids.push(waveformMids[i]);
                    visibleHighs.push(waveformHighs[i]);
                }
            }

            // Split height into 3 bands
            const bandHeight = height / 3;

            // Draw 3-band waveform
            drawBand(svg, visibleIndices, visibleBass, 0, bandHeight, width, '#f44336', viewportDuration); // Bass - red
            drawBand(svg, visibleIndices, visibleMids, bandHeight, bandHeight, width, '#4caf50', viewportDuration); // Mids - green
            drawBand(svg, visibleIndices, visibleHighs, bandHeight * 2, bandHeight, width, '#2196f3', viewportDuration); // Highs - blue

            // Draw separator lines
            const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line1.setAttribute('x1', 0);
            line1.setAttribute('y1', bandHeight);
            line1.setAttribute('x2', width);
            line1.setAttribute('y2', bandHeight);
            line1.setAttribute('stroke', '#666');
            line1.setAttribute('stroke-width', '1');
            svg.appendChild(line1);

            const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line2.setAttribute('x1', 0);
            line2.setAttribute('y1', bandHeight * 2);
            line2.setAttribute('x2', width);
            line2.setAttribute('y2', bandHeight * 2);
            line2.setAttribute('stroke', '#666');
            line2.setAttribute('stroke-width', '1');
            svg.appendChild(line2);

            canvas.appendChild(svg);

            // Add interaction handlers
            setupWaveformInteraction(canvas);

            // Draw overlays
            drawBeatGrid();
            drawMarkers();
            drawPlayhead();
        }

        function drawBand(svg, visibleIndices, visibleSamples, offsetY, bandHeight, width, color, viewportDuration) {
            if (visibleSamples.length === 0) return;

            const center = offsetY + bandHeight / 2;
            const maxAmp = Math.max(...visibleSamples.map(Math.abs));
            const scale = maxAmp > 0 ? (bandHeight / 2 * 0.9) / maxAmp : 1;

            const pixelsPerSample = width / visibleSamples.length;

            if (pixelsPerSample < 2) {
                // High zoom out - use continuous path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d = '';

                visibleSamples.forEach((val, i) => {
                    const idx = visibleIndices[i];
                    const x = ((waveformTimes[idx] - viewportStart) / viewportDuration) * width;
                    const barHeight = Math.abs(val) * scale;

                    if (i === 0) {
                        d += `M ${x} ${center - barHeight}`;
                    } else {
                        d += ` L ${x} ${center - barHeight}`;
                    }
                });

                // Mirror bottom half
                for (let i = visibleSamples.length - 1; i >= 0; i--) {
                    const idx = visibleIndices[i];
                    const x = ((waveformTimes[idx] - viewportStart) / viewportDuration) * width;
                    const barHeight = Math.abs(visibleSamples[i]) * scale;
                    d += ` L ${x} ${center + barHeight}`;
                }

                d += ' Z';
                path.setAttribute('d', d);
                path.setAttribute('fill', color);
                path.setAttribute('opacity', '0.7');
                svg.appendChild(path);
            } else {
                // Zoomed in - draw individual bars
                visibleSamples.forEach((val, i) => {
                    const idx = visibleIndices[i];
                    const x = ((waveformTimes[idx] - viewportStart) / viewportDuration) * width;
                    const barHeight = Math.abs(val) * scale;
                    const barWidth = Math.max(1, pixelsPerSample * 0.8);

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x - barWidth / 2);
                    rect.setAttribute('y', center - barHeight);
                    rect.setAttribute('width', barWidth);
                    rect.setAttribute('height', barHeight * 2);
                    rect.setAttribute('fill', color);
                    rect.setAttribute('opacity', '0.7');
                    svg.appendChild(rect);
                });
            }

            // Draw center line for this band
            const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            centerLine.setAttribute('x1', 0);
            centerLine.setAttribute('y1', center);
            centerLine.setAttribute('x2', width);
            centerLine.setAttribute('y2', center);
            centerLine.setAttribute('stroke', '#444');
            centerLine.setAttribute('stroke-width', '1');
            centerLine.setAttribute('opacity', '0.5');
            svg.appendChild(centerLine);
        }

        function setupWaveformInteraction(canvas) {
            const width = canvas.offsetWidth;

            // Mouse down - start drag or click
            canvas.onmousedown = (e) => {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartViewport = viewportStart;
                canvas.classList.add('dragging');
            };

            // Mouse move - pan viewport if dragging
            canvas.onmousemove = (e) => {
                if (!isDragging) return;

                const dx = e.clientX - dragStartX;
                const viewportDuration = viewportEnd - viewportStart;
                const timeDelta = -(dx / width) * viewportDuration;

                let newStart = dragStartViewport + timeDelta;
                let newEnd = newStart + viewportDuration;

                // Clamp to track bounds
                if (newStart < 0) {
                    newStart = 0;
                    newEnd = viewportDuration;
                }
                if (newEnd > duration) {
                    newEnd = duration;
                    newStart = duration - viewportDuration;
                }

                viewportStart = newStart;
                viewportEnd = newEnd;
                drawWaveform();
            };

            // Mouse up - handle click or end drag
            canvas.onmouseup = (e) => {
                const wasDragging = isDragging;
                isDragging = false;
                canvas.classList.remove('dragging');

                // If didn't drag much, treat as click
                if (!wasDragging || Math.abs(e.clientX - dragStartX) < 5) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    let time = viewportStart + (x / width) * (viewportEnd - viewportStart);

                    // Quantize if enabled
                    if (quantizeEnabled) {
                        time = quantizeToBeat(time);
                    }

                    // Shift key = add boundary
                    if (e.shiftKey) {
                        addBoundary(time);
                        showStatus(`Boundary added at ${formatTime(time)} (Bar ${timeToBar(time)})`);
                    } else {
                        // Normal click = set cue point
                        cuePoint = time;
                        updateCurrentPosition(time);
                        showStatus(`Cue point set at ${formatTime(time)} (Bar ${timeToBar(time)})`);
                    }
                }
            };

            // Mouse leave - cancel drag
            canvas.onmouseleave = () => {
                isDragging = false;
                canvas.classList.remove('dragging');
            };

            // Mouse wheel - zoom
            canvas.onwheel = (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const centerTime = viewportStart + (x / width) * (viewportEnd - viewportStart);

                zoom(e.deltaY < 0 ? 1 : -1, centerTime);
            };
        }

        function drawBeatGrid() {
            // Remove old grid lines and numbers
            document.querySelectorAll('.beat-grid-line, .bar-number').forEach(l => l.remove());

            const canvas = document.getElementById('waveform');
            const width = canvas.offsetWidth;
            const beatDuration = 60.0 / trackBPM;  // One beat in seconds
            const barDuration = beatDuration * 4;  // One bar in seconds

            // Only draw grid if zoomed in enough (otherwise too dense)
            const viewportDuration = viewportEnd - viewportStart;
            const pixelsPerBeat = (width / viewportDuration) * beatDuration;
            const pixelsPerBar = (width / viewportDuration) * barDuration;

            // Draw downbeat marker
            if (trackDownbeat >= viewportStart && trackDownbeat <= viewportEnd) {
                const x = ((trackDownbeat - viewportStart) / viewportDuration) * width;
                const line = document.createElement('div');
                line.className = 'beat-grid-line downbeat';
                line.style.left = x + 'px';
                canvas.appendChild(line);

                // Add "1" label for downbeat
                if (pixelsPerBar > 30) {
                    const label = document.createElement('div');
                    label.className = 'bar-number';
                    label.textContent = '1';
                    label.style.left = x + 'px';
                    canvas.appendChild(label);
                }
            }

            // Draw bar lines if zoomed in enough
            if (pixelsPerBeat > 5) {  // Only show if at least 5px per beat
                // Find first bar in viewport
                const firstBar = Math.floor((viewportStart - trackDownbeat) / barDuration);
                const lastBar = Math.ceil((viewportEnd - trackDownbeat) / barDuration);

                for (let bar = firstBar; bar <= lastBar; bar++) {
                    const barTime = trackDownbeat + bar * barDuration;
                    const barNumber = bar + 1;  // 1-indexed

                    if (barTime >= viewportStart && barTime <= viewportEnd && barTime !== trackDownbeat) {
                        const x = ((barTime - viewportStart) / viewportDuration) * width;
                        const line = document.createElement('div');
                        line.className = 'beat-grid-line bar';
                        line.style.left = x + 'px';
                        canvas.appendChild(line);

                        // Add bar number if enough space
                        if (pixelsPerBar > 30) {
                            const label = document.createElement('div');
                            label.className = 'bar-number';
                            label.textContent = barNumber;
                            label.style.left = x + 'px';
                            canvas.appendChild(label);
                        }
                    }

                    // Draw individual beats if zoomed in more
                    if (pixelsPerBeat > 20) {
                        for (let beat = 1; beat < 4; beat++) {
                            const beatTime = barTime + beat * beatDuration;
                            if (beatTime >= viewportStart && beatTime <= viewportEnd) {
                                const x = ((beatTime - viewportStart) / viewportDuration) * width;
                                const line = document.createElement('div');
                                line.className = 'beat-grid-line beat';
                                line.style.left = x + 'px';
                                canvas.appendChild(line);
                            }
                        }
                    }
                }
            }
        }

        function drawMarkers() {
            // Remove old markers and regions
            document.querySelectorAll('.marker, .region-overlay').forEach(m => m.remove());

            const canvas = document.getElementById('waveform');
            const width = canvas.offsetWidth;
            const viewportDuration = viewportEnd - viewportStart;

            // Draw regions as colored overlays
            regions.forEach((r, i) => {
                // Only draw if in viewport
                if (r.end > viewportStart && r.start < viewportEnd) {
                    const startX = Math.max(0, ((r.start - viewportStart) / viewportDuration) * width);
                    const endX = Math.min(width, ((r.end - viewportStart) / viewportDuration) * width);
                    const regionWidth = endX - startX;

                    if (regionWidth > 0) {
                        const overlay = document.createElement('div');
                        overlay.className = 'region-overlay';
                        overlay.style.left = startX + 'px';
                        overlay.style.width = regionWidth + 'px';
                        overlay.style.background = getLabelColor(r.label);
                        overlay.style.opacity = '0.25';
                        overlay.style.pointerEvents = 'none';
                        canvas.appendChild(overlay);
                    }
                }
            });

            // Draw boundaries as vertical lines
            boundaries.forEach((time, i) => {
                // Only draw if in viewport
                if (time >= viewportStart && time <= viewportEnd) {
                    const x = ((time - viewportStart) / viewportDuration) * width;
                    const marker = document.createElement('div');
                    marker.className = 'marker';
                    marker.style.left = x + 'px';
                    marker.style.background = '#ffffff';
                    marker.style.width = '2px';
                    marker.style.cursor = 'pointer';
                    marker.onclick = (e) => {
                        e.stopPropagation();
                        removeBoundary(time);
                    };

                    const label = document.createElement('div');
                    label.className = 'marker-label';
                    const bar = timeToBar(time);
                    label.textContent = `${formatTime(time)} [Bar ${bar}]`;
                    label.style.background = 'rgba(0, 0, 0, 0.8)';
                    marker.appendChild(label);

                    canvas.appendChild(marker);
                }
            });
        }

        function getLabelColor(label) {
            const colors = {
                intro: '#4caf50',
                buildup: '#ff9800',
                breakdown: '#2196f3',
                breakbuild: '#9c27b0',
                outro: '#673ab7',
                unlabeled: '#757575'
            };
            return colors[label] || '#757575';
        }

        function addBoundary(time) {
            boundaries.push(time);
            boundaries.sort((a, b) => a - b);
            rebuildRegions();
            updateRegionList();
            drawMarkers();
        }

        function addBoundaryAtPlayhead() {
            if (!currentTrack) {
                alert('Load a track first!');
                return;
            }

            let time = currentTime;

            // Quantize if enabled
            if (quantizeEnabled) {
                time = quantizeToBeat(time);
            }

            // Check if boundary already exists at this time (within 0.01s)
            const exists = boundaries.some(b => Math.abs(b - time) < 0.01);
            if (exists) {
                showStatus('Boundary already exists at this position');
                return;
            }

            addBoundary(time);
            showStatus(`Boundary added at ${formatTime(time)} (Bar ${timeToBar(time)})`);
        }

        function removeBoundary(time) {
            const index = boundaries.indexOf(time);
            if (index !== -1) {
                boundaries.splice(index, 1);
                rebuildRegions();
                updateRegionList();
                drawMarkers();
            }
        }

        function rebuildRegions() {
            // Save existing region labels
            const oldRegions = [...regions];
            regions = [];

            // Create regions between consecutive boundaries
            for (let i = 0; i < boundaries.length - 1; i++) {
                const existingRegion = oldRegions.find(r => r.start === boundaries[i] && r.end === boundaries[i + 1]);
                const label = existingRegion ? existingRegion.label : 'unlabeled';
                regions.push({
                    start: boundaries[i],
                    end: boundaries[i + 1],
                    label: label
                });
            }

            // Add region from last boundary to end if it's not already at the end
            if (boundaries.length > 0) {
                const lastBoundary = boundaries[boundaries.length - 1];
                // Only add if last boundary is before the end of the track
                if (lastBoundary < duration - 0.01) {  // Small tolerance for floating point
                    const existingRegion = oldRegions.find(r => r.start === lastBoundary && r.end === duration);
                    const label = existingRegion ? existingRegion.label : 'unlabeled';
                    regions.push({
                        start: lastBoundary,
                        end: duration,
                        label: label
                    });
                }
            }
        }

        function updateRegionList() {
            const list = document.getElementById('regionList');
            document.getElementById('regionCount').textContent = regions.length;

            if (regions.length === 0) {
                list.innerHTML = '<p style="color: #888;">No regions yet. Use "+ Add Boundary" button to create boundaries.</p>';
                return;
            }

            list.innerHTML = regions.map((r, i) => {
                const startBar = timeToBar(r.start);
                const endBar = timeToBar(r.end);
                return `
                    <div class="boundary-item" onmouseenter="highlightRegion(${i})" onmouseleave="unhighlightRegion()">
                        <div class="boundary-info">
                            <span class="boundary-time">${formatTime(r.start)} - ${formatTime(r.end)}</span>
                            <span class="boundary-bar">Bar ${startBar} - ${endBar}</span>
                            <select class="label-dropdown" onchange="setRegionLabel(${i}, this.value)" onclick="event.stopPropagation()">
                                <option value="intro" ${r.label === 'intro' ? 'selected' : ''}>Intro</option>
                                <option value="buildup" ${r.label === 'buildup' ? 'selected' : ''}>Buildup</option>
                                <option value="breakdown" ${r.label === 'breakdown' ? 'selected' : ''}>Breakdown</option>
                                <option value="breakbuild" ${r.label === 'breakbuild' ? 'selected' : ''}>Breakbuild</option>
                                <option value="outro" ${r.label === 'outro' ? 'selected' : ''}>Outro</option>
                                <option value="unlabeled" ${r.label === 'unlabeled' ? 'selected' : ''}>Unlabeled</option>
                            </select>
                        </div>
                        <button class="btn-delete" onclick="event.stopPropagation(); removeBoundary(${r.start})">Delete</button>
                    </div>
                `;
            }).join('');
        }

        function setRegionLabel(index, label) {
            if (index >= 0 && index < regions.length) {
                regions[index].label = label;
                updateRegionList();
                drawMarkers();
            }
        }

        function highlightRegion(index) {
            // Remove any existing highlights
            document.querySelectorAll('.region-overlay').forEach(overlay => {
                overlay.classList.remove('highlight');
            });

            // Highlight the specific region
            const overlays = document.querySelectorAll('.region-overlay');
            if (index >= 0 && index < overlays.length) {
                overlays[index].classList.add('highlight');
            }
        }

        function unhighlightRegion() {
            document.querySelectorAll('.region-overlay').forEach(overlay => {
                overlay.classList.remove('highlight');
            });
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(2);
            return `${mins}:${secs.padStart(5, '0')}`;
        }

        function saveAnnotation() {
            if (!currentTrack) {
                alert('Load a track first!');
                return;
            }
            if (regions.length === 0) {
                alert('Add at least one region!');
                return;
            }

            const bpm = parseFloat(document.getElementById('bpmInput').value);
            const downbeat = parseFloat(document.getElementById('downbeatInput').value);

            if (!bpm || bpm < 60 || bpm > 200) {
                alert('Enter a valid BPM (60-200)');
                return;
            }

            // Convert regions to boundary format for backend
            const boundariesForSave = regions.map(r => ({
                time: r.start,
                label: r.label
            }));

            const data = {
                filename: currentTrack.filename,
                bpm,
                downbeat,
                boundaries: boundariesForSave
            };

            fetch('/api/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(r => r.json())
            .then(result => {
                showStatus(`âœ“ Saved! ${result.boundaries_count} boundaries â†’ ${result.output}`);
            })
            .catch(err => {
                alert('Save failed: ' + err);
            });
        }

        function showStatus(msg) {
            const status = document.getElementById('status');
            status.textContent = msg;
            status.style.display = 'block';
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }

        // Auto-reload on server restart (development only)
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            let lastCheck = Date.now();
            setInterval(() => {
                fetch('/api/tracks', { method: 'HEAD' })
                    .catch(() => {
                        // Server is restarting, wait a bit then reload
                        setTimeout(() => location.reload(), 1000);
                    });
            }, 1000);
        }
    </script>
</body>
</html>
