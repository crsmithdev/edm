<openspec-context>
  <purpose>OpenSpec workflow: structured change management with proposals, designs, tasks</purpose>

  <workflow>
    <flow>proposal → design → tasks → implement</flow>
    <states>draft → in-progress → ready → deployed → archived</states>
  </workflow>

  <structure>
    <dir path="openspec/specs/" role="system requirements (authoritative)"/>
    <dir path="openspec/changes/[CODE-name]/">
      <file name="proposal.md" content="why/what/impact"/>
      <file name="design.md" content="how (technical)"/>
      <file name="tasks.md" content="checklist"/>
    </dir>
    <dir path="openspec/archive/" role="deployed changes (reference)"/>
  </structure>

  <proposal>
    <frontmatter status="draft|in-progress|ready|deployed" created="YYYY-MM-DD" updated="auto"/>
    <sections why="problem/motivation" what="files/specs affected" impact="breaking/migrations/risks"/>
    <naming format="[CODE]Proposal Name" example="[AUTH]Add JWT Authentication"/>
  </proposal>

  <design>
    <sections approach="strategy" implementation="file-by-file" testing="strategy" risks="trade-offs"/>
    <style>Concise technical, not prose</style>
  </design>

  <tasks>
    <format>Hierarchical markdown checklist</format>
    <group by="phase" example="## 1. Core Implementation"/>
    <item format="- [ ] 1.1 Create foo.py" done="- [x] 1.1 Create foo.py"/>
  </tasks>

  <rules>
    <strict>Proposals reference affected specs</strict>
    <strict>Design covers implementation approach</strict>
    <strict>Tasks are checkable (no ambiguity)</strict>
    <strict>Changes stay scoped (no feature creep)</strict>
    <strict>Archive updates specs to reflect deployed state</strict>
  </rules>

  <commands>
    <cmd name="/propose">scaffold new change</cmd>
    <cmd name="/list">view all proposals and status</cmd>
    <cmd name="/apply" arg="CODE">implement change, update tasks</cmd>
    <cmd name="/archive" arg="CODE">move to archive, update specs</cmd>
  </commands>
</openspec-context>
